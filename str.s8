; str.s8 â€” minimal string helpers (library, not kernel)
;
; All strings are ASCII, NUL-terminated (0x00), matching kernel PUTS.
; No registers preserved unless noted.

; ---------------------------------------------------------------------------
; STRLEN
;   Compute string length.
;   Args:
;     R1:R2 = pointer to NUL-terminated string
;   Returns:
;     R0 = length (0..255), wraps if longer
;   Clobbers: R0, R3
;   Notes:
;     This advances R1:R2 while scanning.
; ---------------------------------------------------------------------------
STRLEN:
    SET #0x00, R0
STRLEN_LOOP:
    LOADR R3, R1, R2
    JZ R3, STRLEN_DONE

    INC R0

    ; ++ptr
    INC R2
    JNZ R2, STRLEN_LOOP
    INC R1
    JMP STRLEN_LOOP
STRLEN_DONE:
    RET

; ---------------------------------------------------------------------------
; STREQ
;   Compare two strings for equality.
;   Args:
;     R1:R2 = s1
;     R3:R4 = s2
;   Returns:
;     R0 = 1 if equal, 0 otherwise
;   Clobbers: R0, R5, R6, R7
;   Notes:
;     Advances both pointers.
; ---------------------------------------------------------------------------
STREQ:
STREQ_LOOP:
    LOADR R5, R1, R2      ; ch1
    LOADR R6, R3, R4      ; ch2

    ; if ch1 != ch2 => not equal
    SET #0x00, R7
    ADDR R5, R7           ; R7 = ch1
    CMPR R7, R6           ; R7 = ch1 - ch2
    JNZ R7, STREQ_NO

    ; if ch1 == 0 => both are NUL => equal
    JZ R5, STREQ_YES

    ; ++s1
    INC R2
    JNZ R2, STREQ_S1_OK
    INC R1
STREQ_S1_OK:

    ; ++s2
    INC R4
    JNZ R4, STREQ_LOOP
    INC R3
    JMP STREQ_LOOP

STREQ_NO:
    SET #0x00, R0
    RET
STREQ_YES:
    SET #0x01, R0
    RET

; ---------------------------------------------------------------------------
; STRCPY
;   Copy NUL-terminated string (including terminator).
;   Args:
;     R1:R2 = dst
;     R3:R4 = src
;   Returns: none
;   Clobbers: R5
; ---------------------------------------------------------------------------
STRCPY:
STRCPY_LOOP:
    LOADR R5, R3, R4
    STORER R5, R1, R2
    JZ R5, STRCPY_DONE

    ; ++src
    INC R4
    JNZ R4, STRCPY_SRC_OK
    INC R3
STRCPY_SRC_OK:

    ; ++dst
    INC R2
    JNZ R2, STRCPY_LOOP
    INC R1
    JMP STRCPY_LOOP
STRCPY_DONE:
    RET

; ---------------------------------------------------------------------------
; STRNCPY
;   Bounded copy: copies at most R5 bytes INCLUDING terminator.
;   Always writes a terminator if R5 > 0.
;   Args:
;     R1:R2 = dst
;     R3:R4 = src
;     R5    = max bytes to write (>=1 recommended)
;   Returns: none
;   Clobbers: R5, R6
; ---------------------------------------------------------------------------
STRNCPY:
    JZ R5, STRNCPY_DONE
STRNCPY_LOOP:
    ; if last byte, force terminator
    SET #0x00, R6
    ADDR R5, R6
    DEC R6
    JZ R6, STRNCPY_FORCE_NUL

    LOADR R6, R3, R4
    STORER R6, R1, R2
    JZ R6, STRNCPY_DONE

    ; ++src
    INC R4
    JNZ R4, STRNCPY_SRC_OK
    INC R3
STRNCPY_SRC_OK:

    ; ++dst
    INC R2
    JNZ R2, STRNCPY_DST_OK
    INC R1
STRNCPY_DST_OK:

    DEC R5
    JMP STRNCPY_LOOP

STRNCPY_FORCE_NUL:
    SET #0x00, R6
    STORER R6, R1, R2
STRNCPY_DONE:
    RET

; ---------------------------------------------------------------------------
; STRCMP
;   Lexicographic compare.
;   Args:
;     R1:R2 = s1
;     R3:R4 = s2
;   Returns:
;     R0 = 0x00 if equal
;          0xFF if s1 < s2
;          0x01 if s1 > s2
;   Clobbers: R5, R6
;   Notes:
;     Advances both pointers.
; ---------------------------------------------------------------------------
STRCMP:
STRCMP_LOOP:
    LOADR R5, R1, R2
    LOADR R6, R3, R4

    SET #0x00, R0
    ADDR R5, R0
    CMPR R0, R6
    JZ R0, STRCMP_EQ_CHAR

    JC STRCMP_LT
    SET #0x01, R0
    RET
STRCMP_LT:
    SET #0xFF, R0
    RET

STRCMP_EQ_CHAR:
    ; if both NUL => equal
    JZ R5, STRCMP_EQUAL

    ; ++s1
    INC R2
    JNZ R2, STRCMP_S1_OK
    INC R1
STRCMP_S1_OK:

    ; ++s2
    INC R4
    JNZ R4, STRCMP_LOOP
    INC R3
    JMP STRCMP_LOOP

STRCMP_EQUAL:
    SET #0x00, R0
    RET

; ---------------------------------------------------------------------------
; STRCHR
;   Find first occurrence of a character.
;   Args:
;     R1:R2 = string
;     R0    = character to find
;   Returns:
;     R1:R2 = pointer to match, or 0x0000 if not found
;     R4    = 1 if found else 0
;   Clobbers: R5
; ---------------------------------------------------------------------------
STRCHR:
    SET #0x00, R4
STRCHR_LOOP:
    LOADR R5, R1, R2

    ; check match
    SET #0x00, R4
    ADDR R5, R4
    CMPR R4, R0
    JZ R4, STRCHR_FOUND

    ; if NUL and not match => not found
    JZ R5, STRCHR_NOT_FOUND

    ; ++ptr
    INC R2
    JNZ R2, STRCHR_LOOP
    INC R1
    JMP STRCHR_LOOP

STRCHR_FOUND:
    SET #0x01, R4
    RET

STRCHR_NOT_FOUND:
    SET #0x00, R1
    SET #0x00, R2
    SET #0x00, R4
    RET
