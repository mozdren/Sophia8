; mem.s8 â€” small memory helpers (library, not kernel)
;
; Calling convention (all routines):
;   Arguments in registers as documented per routine.
;   No registers preserved unless noted.

; ---------------------------------------------------------------------------
; MEMSET
;   Fill memory with a byte value.
;   Args:
;     R1:R2 = dst pointer
;     R0    = value
;     R3    = length (bytes)
;   Returns: none
;   Clobbers: R3, R4
; ---------------------------------------------------------------------------
MEMSET:
MEMSET_LOOP:
    JZ R3, MEMSET_DONE
    STORER R0, R1, R2

    ; ++dst
    INC R2
    JNZ R2, MEMSET_PTR_OK
    INC R1
MEMSET_PTR_OK:

    DEC R3
    JMP MEMSET_LOOP
MEMSET_DONE:
    RET

; ---------------------------------------------------------------------------
; MEMCPY
;   Copy memory (forward) byte-by-byte.
;   Args:
;     R1:R2 = dst pointer
;     R3:R4 = src pointer
;     R5    = length (bytes)
;   Returns: none
;   Clobbers: R0, R5
; ---------------------------------------------------------------------------
MEMCPY:
MEMCPY_LOOP:
    JZ R5, MEMCPY_DONE
    LOADR R0, R3, R4
    STORER R0, R1, R2

    ; ++src
    INC R4
    JNZ R4, MEMCPY_SRC_OK
    INC R3
MEMCPY_SRC_OK:

    ; ++dst
    INC R2
    JNZ R2, MEMCPY_DST_OK
    INC R1
MEMCPY_DST_OK:

    DEC R5
    JMP MEMCPY_LOOP
MEMCPY_DONE:
    RET

; ---------------------------------------------------------------------------
; MEMMOVE
;   Copy memory safely even when ranges overlap.
;   Args:
;     R1:R2 = dst pointer
;     R3:R4 = src pointer
;     R5    = length (bytes)
;   Returns: none
;   Clobbers: R0, R5, R6, R7
;   Notes:
;     - If dst < src OR dst >= src+len => copies forward.
;     - Otherwise copies backward.
; ---------------------------------------------------------------------------
MEMMOVE:
    JZ R5, MEMMOVE_DONE

    ; If dst < src => forward.
    SET #0x00, R6
    ADDR R1, R6           ; tmp = dst_hi
    CMPR R6, R3           ; tmp = dst_hi - src_hi
    JC MEMMOVE_FWD
    JNZ R6, MEMMOVE_CHECK_END

    SET #0x00, R6
    ADDR R2, R6           ; tmp = dst_lo
    CMPR R6, R4           ; tmp = dst_lo - src_lo
    JC MEMMOVE_FWD

MEMMOVE_CHECK_END:
    ; Compute end = src + len in R6:R7
    SET #0x00, R6
    ADDR R3, R6
    SET #0x00, R7
    ADDR R4, R7
    ADDR R5, R7
    JNC MEMMOVE_END_OK
    INC R6
MEMMOVE_END_OK:

    ; If dst >= end => forward, else backward.
    SET #0x00, R0
    ADDR R1, R0           ; tmp = dst_hi
    CMPR R0, R6           ; tmp = dst_hi - end_hi
    JC MEMMOVE_BWD
    JNZ R0, MEMMOVE_FWD

    SET #0x00, R0
    ADDR R2, R0           ; tmp = dst_lo
    CMPR R0, R7           ; tmp = dst_lo - end_lo
    JC MEMMOVE_BWD
    JMP MEMMOVE_FWD

MEMMOVE_FWD:
MEMMOVE_FWD_LOOP:
    JZ R5, MEMMOVE_DONE
    LOADR R0, R3, R4
    STORER R0, R1, R2

    ; ++src
    INC R4
    JNZ R4, MEMMOVE_FWD_SRC_OK
    INC R3
MEMMOVE_FWD_SRC_OK:

    ; ++dst
    INC R2
    JNZ R2, MEMMOVE_FWD_DST_OK
    INC R1
MEMMOVE_FWD_DST_OK:

    DEC R5
    JMP MEMMOVE_FWD_LOOP

MEMMOVE_BWD:
    ; Backward copy: set src = src+len-1, dst = dst+len-1

    ; src_end (R6:R7) = src + len
    SET #0x00, R6
    ADDR R3, R6
    SET #0x00, R7
    ADDR R4, R7
    ADDR R5, R7
    JNC MEMMOVE_BWD_SRC_ADD_OK
    INC R6
MEMMOVE_BWD_SRC_ADD_OK:
    ; --src_end
    DEC R7
    JNC MEMMOVE_BWD_SRC_DEC_OK
    DEC R6
MEMMOVE_BWD_SRC_DEC_OK:

    ; dst_end (reuse R3:R4) = dst + len
    SET #0x00, R3
    ADDR R1, R3
    SET #0x00, R4
    ADDR R2, R4
    ADDR R5, R4
    JNC MEMMOVE_BWD_DST_ADD_OK
    INC R3
MEMMOVE_BWD_DST_ADD_OK:
    ; --dst_end
    DEC R4
    JNC MEMMOVE_BWD_DST_DEC_OK
    DEC R3
MEMMOVE_BWD_DST_DEC_OK:

MEMMOVE_BWD_LOOP:
    JZ R5, MEMMOVE_DONE
    LOADR R0, R6, R7
    STORER R0, R3, R4

    ; --src
    DEC R7
    JNC MEMMOVE_BWD_SRC_OK
    DEC R6
MEMMOVE_BWD_SRC_OK:

    ; --dst
    DEC R4
    JNC MEMMOVE_BWD_DST_OK
    DEC R3
MEMMOVE_BWD_DST_OK:

    DEC R5
    JMP MEMMOVE_BWD_LOOP

MEMMOVE_DONE:
    RET

; ---------------------------------------------------------------------------
; MEMCMP
;   Compare two memory ranges.
;   Args:
;     R1:R2 = a
;     R3:R4 = b
;     R5    = length
;   Returns:
;     R0 = 0x00 if equal
;          0xFF if a < b (at first differing byte)
;          0x01 if a > b
;   Clobbers: R6, R7
; ---------------------------------------------------------------------------
MEMCMP:
MEMCMP_LOOP:
    JZ R5, MEMCMP_EQUAL

    LOADR R6, R1, R2
    LOADR R7, R3, R4

    SET #0x00, R0
    ADDR R6, R0
    CMPR R0, R7
    JZ R0, MEMCMP_NEXT
    JC MEMCMP_LT
    SET #0x01, R0
    RET
MEMCMP_LT:
    SET #0xFF, R0
    RET

MEMCMP_NEXT:
    ; ++a
    INC R2
    JNZ R2, MEMCMP_A_OK
    INC R1
MEMCMP_A_OK:

    ; ++b
    INC R4
    JNZ R4, MEMCMP_B_OK
    INC R3
MEMCMP_B_OK:

    DEC R5
    JMP MEMCMP_LOOP

MEMCMP_EQUAL:
    SET #0x00, R0
    RET

; ---------------------------------------------------------------------------
; MEMCHR
;   Find a byte in a memory range.
;   Args:
;     R1:R2 = start
;     R0    = byte to find
;     R3    = length
;   Returns:
;     R1:R2 = pointer to first match, or 0x0000 if not found
;     R4    = 1 if found else 0
;   Clobbers: R3, R5
; ---------------------------------------------------------------------------
MEMCHR:
    SET #0x00, R4
MEMCHR_LOOP:
    JZ R3, MEMCHR_NOT_FOUND

    LOADR R5, R1, R2

    ; compare loaded (R5) with target (R0)
    SET #0x00, R4
    ADDR R5, R4
    CMPR R4, R0
    JZ R4, MEMCHR_FOUND

    ; ++ptr
    INC R2
    JNZ R2, MEMCHR_PTR_OK
    INC R1
MEMCHR_PTR_OK:

    DEC R3
    JMP MEMCHR_LOOP

MEMCHR_FOUND:
    SET #0x01, R4
    RET

MEMCHR_NOT_FOUND:
    SET #0x00, R1
    SET #0x00, R2
    SET #0x00, R4
    RET
