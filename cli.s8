; cli.s8 â€” small console helpers (library, not kernel)
;
; Depends on kernel.s8 for GETC and PUTC and PUTS.
; No registers preserved unless noted.

; ---------------------------------------------------------------------------
; READLINE_ECHO
;   Read a line from console into a buffer (blocking), echoing input.
;
;   - Stops on '\n' (0x0A) or '\r' (0x0D)
;   - Supports backspace (0x08) and DEL (0x7F)
;   - Always NUL-terminates
;
;   Args:
;     R1:R2 = destination buffer
;     R3    = max length INCLUDING terminator (>=1 recommended)
;   Returns:
;     R4 = length (not including terminator)
;   Clobbers: R0, R3, R5, R6, R7
; ---------------------------------------------------------------------------
READLINE_ECHO:
    SET #0x00, R4          ; length

    ; remaining = max-1 (space for terminator)
    SET #0x00, R5
    ADDR R3, R5
    JZ R5, RL_DONE_TERM    ; if max==0, just terminate (best-effort)
    DEC R5                 ; remaining data bytes

RL_LOOP:
    ; if no remaining space, stop
    JZ R5, RL_DONE_TERM

    CALL GETC              ; R0 = char

    ; check '\n'
    SET #0x00, R6
    ADDR R0, R6
    CMP R6, #0x0A
    JZ R6, RL_DONE_TERM

    ; check '\r'
    SET #0x00, R6
    ADDR R0, R6
    CMP R6, #0x0D
    JZ R6, RL_DONE_TERM

    ; check backspace (0x08)
    SET #0x00, R6
    ADDR R0, R6
    CMP R6, #0x08
    JZ R6, RL_BACKSPACE

    ; check DEL (0x7F)
    SET #0x00, R6
    ADDR R0, R6
    CMP R6, #0x7F
    JZ R6, RL_BACKSPACE

    ; store char
    STORER R0, R1, R2
    CALL PUTC              ; echo

    ; ++ptr
    INC R2
    JNZ R2, RL_PTR_OK
    INC R1
RL_PTR_OK:

    INC R4                 ; len++
    DEC R5                 ; remaining--
    JMP RL_LOOP

RL_BACKSPACE:
    ; if len == 0, nothing to do
    JZ R4, RL_LOOP

    ; move pointer back by 1
    DEC R2
    ; if R2 didn't underflow, ok
    JNC RL_PTR_BACK_OK
    ; underflow: borrow happened, so high--
    DEC R1
RL_PTR_BACK_OK:

    DEC R4
    INC R5                 ; give space back

    ; erase on screen: "\b \b"
    SET #0x08, R0
    CALL PUTC
    SET #0x20, R0
    CALL PUTC
    SET #0x08, R0
    CALL PUTC

    JMP RL_LOOP

RL_DONE_TERM:
    ; write NUL terminator
    SET #0x00, R0
    STORER R0, R1, R2
    RET

; ---------------------------------------------------------------------------
; SKIPSPACES
;   Advance pointer over spaces and tabs.
;   Args:
;     R1:R2 = pointer
;   Returns:
;     R1:R2 = advanced pointer
;   Clobbers: R0, R6
; ---------------------------------------------------------------------------
SKIPSPACES:
SKIPSPACES_LOOP:
    LOADR R0, R1, R2
    ; stop on NUL
    JZ R0, SKIPSPACES_DONE

    ; if char == ' ' (0x20) or '\t' (0x09) => skip
    SET #0x00, R6
    ADDR R0, R6
    CMP R6, #0x20
    JZ R6, SKIPSPACES_ADV

    SET #0x00, R6
    ADDR R0, R6
    CMP R6, #0x09
    JZ R6, SKIPSPACES_ADV

    JMP SKIPSPACES_DONE

SKIPSPACES_ADV:
    INC R2
    JNZ R2, SKIPSPACES_LOOP
    INC R1
    JMP SKIPSPACES_LOOP

SKIPSPACES_DONE:
    RET

; ---------------------------------------------------------------------------
; READTOKEN
;   Read a space-delimited token from a string.
;   Args:
;     R1:R2 = src pointer
;     R3:R4 = dst buffer
;     R5    = max bytes to write INCLUDING NUL (>=1 recommended)
;   Returns:
;     R6 = token length (excluding terminator)
;     R1:R2 = updated src pointer (points at delimiter or NUL)
;   Clobbers: R0, R5, R6, R7
;   Notes:
;     - Leading spaces/tabs are skipped.
;     - Token ends on space/tab or NUL.
;     - Always NUL-terminates if R5>0.
; ---------------------------------------------------------------------------
READTOKEN:
    SET #0x00, R6
    CALL SKIPSPACES

    ; if no room, nothing
    JZ R5, READTOKEN_DONE

READTOKEN_LOOP:
    ; if last byte reserved for NUL, stop
    SET #0x00, R7
    ADDR R5, R7
    DEC R7
    JZ R7, READTOKEN_TERM

    LOADR R0, R1, R2
    JZ R0, READTOKEN_TERM

    ; delimiter? ' ' or '\t'
    SET #0x00, R7
    ADDR R0, R7
    CMP R7, #0x20
    JZ R7, READTOKEN_TERM

    SET #0x00, R7
    ADDR R0, R7
    CMP R7, #0x09
    JZ R7, READTOKEN_TERM

    ; store char
    STORER R0, R3, R4

    ; ++src
    INC R2
    JNZ R2, READTOKEN_SRC_OK
    INC R1
READTOKEN_SRC_OK:

    ; ++dst
    INC R4
    JNZ R4, READTOKEN_DST_OK
    INC R3
READTOKEN_DST_OK:

    INC R6
    DEC R5
    JMP READTOKEN_LOOP

READTOKEN_TERM:
    SET #0x00, R0
    STORER R0, R3, R4
READTOKEN_DONE:
    RET

; ---------------------------------------------------------------------------
; PARSE_U8_DEC
;   Parse an unsigned decimal integer (0..255).
;   Args:
;     R1:R2 = pointer to text (leading spaces/tabs allowed)
;   Returns:
;     R0 = parsed value (undefined if R4==0)
;     R4 = 1 on success, 0 on failure (no digits or overflow)
;     R1:R2 = advanced pointer (after last digit on success)
;   Clobbers: R5, R6, R7
; ---------------------------------------------------------------------------
PARSE_U8_DEC:
    CALL SKIPSPACES
    SET #0x00, R4          ; success flag
    SET #0x00, R6          ; value low
    SET #0x00, R7          ; value high (overflow detect)

PARSE_U8_DEC_LOOP:
    LOADR R5, R1, R2
    JZ R5, PARSE_U8_DEC_DONE

    ; check digit '0'..'9'
    SET #0x00, R0
    ADDR R5, R0
    CMP R0, #0x30
    JC PARSE_U8_DEC_DONE           ; < '0'

    SET #0x00, R0
    ADDR R5, R0
    CMP R0, #0x3A
    JC PARSE_U8_DEC_IS_DIGIT       ; < ':' => digit
    JMP PARSE_U8_DEC_DONE

PARSE_U8_DEC_IS_DIGIT:
    ; have at least one digit
    SET #0x01, R4

    ; digit = ch - '0' into R5
    SET #0x00, R0
    ADDR R5, R0
    SUB #0x30, R0
    SET #0x00, R5
    ADDR R0, R5

    ; value = value*10 + digit
    ; VM encoding order is: MUL imm, dst_high, dst_low
    ; We want low in R6, high in R7.
    MUL #10, R7, R6
    JNC PARSE_U8_DEC_MUL_OK
    JMP PARSE_U8_DEC_OVERFLOW
PARSE_U8_DEC_MUL_OK:

    ADDR R5, R6
    JNC PARSE_U8_DEC_ADD_OK
    INC R7
PARSE_U8_DEC_ADD_OK:
    JNZ R7, PARSE_U8_DEC_OVERFLOW

    ; ++ptr
    INC R2
    JNZ R2, PARSE_U8_DEC_LOOP
    INC R1
    JMP PARSE_U8_DEC_LOOP

PARSE_U8_DEC_OVERFLOW:
    SET #0x00, R4
    RET

PARSE_U8_DEC_DONE:
    JZ R4, PARSE_U8_DEC_FAIL
    SET #0x00, R0
    ADDR R6, R0
    RET
PARSE_U8_DEC_FAIL:
    RET
