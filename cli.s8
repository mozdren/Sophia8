; cli.s8 â€” small console helpers (library, not kernel)
;
; Depends on kernel.s8 for GETC and PUTC and PUTS.
; No registers preserved unless noted.

; ---------------------------------------------------------------------------
; READLINE_ECHO
;   Read a line from console into a buffer (blocking), echoing input.
;
;   - Stops on '\n' (0x0A) or '\r' (0x0D)
;   - Supports backspace (0x08) and DEL (0x7F)
;   - Always NUL-terminates
;
;   Args:
;     R1:R2 = destination buffer
;     R3    = max length INCLUDING terminator (>=1 recommended)
;   Returns:
;     R4 = length (not including terminator)
;   Clobbers: R0, R3, R5, R6, R7
; ---------------------------------------------------------------------------
READLINE_ECHO:
    SET #0x00, R4          ; length

    ; remaining = max-1 (space for terminator)
    SET #0x00, R5
    ADDR R3, R5
    JZ R5, RL_DONE_TERM    ; if max==0, just terminate (best-effort)
    DEC R5                 ; remaining data bytes

RL_LOOP:
    ; if no remaining space, stop
    JZ R5, RL_DONE_TERM

    CALL GETC              ; R0 = char

    ; check '\n'
    SET #0x00, R6
    ADDR R0, R6
    CMP R6, #0x0A
    JZ R6, RL_DONE_TERM

    ; check '\r'
    SET #0x00, R6
    ADDR R0, R6
    CMP R6, #0x0D
    JZ R6, RL_DONE_TERM

    ; check backspace (0x08)
    SET #0x00, R6
    ADDR R0, R6
    CMP R6, #0x08
    JZ R6, RL_BACKSPACE

    ; check DEL (0x7F)
    SET #0x00, R6
    ADDR R0, R6
    CMP R6, #0x7F
    JZ R6, RL_BACKSPACE

    ; store char
    STORER R0, R1, R2
    CALL PUTC              ; echo

    ; ++ptr
    INC R2
    JNZ R2, RL_PTR_OK
    INC R1
RL_PTR_OK:

    INC R4                 ; len++
    DEC R5                 ; remaining--
    JMP RL_LOOP

RL_BACKSPACE:
    ; if len == 0, nothing to do
    JZ R4, RL_LOOP

    ; move pointer back by 1
    DEC R2
    ; if R2 didn't underflow, ok
    JNC RL_PTR_BACK_OK
    ; underflow: borrow happened, so high--
    DEC R1
RL_PTR_BACK_OK:

    DEC R4
    INC R5                 ; give space back

    ; erase on screen: "\b \b"
    SET #0x08, R0
    CALL PUTC
    SET #0x20, R0
    CALL PUTC
    SET #0x08, R0
    CALL PUTC

    JMP RL_LOOP

RL_DONE_TERM:
    ; write NUL terminator
    SET #0x00, R0
    STORER R0, R1, R2
    RET


; ---------------------------------------------------------------------------
; SKIPSPACES
;   Advance a pointer over ASCII spaces and tabs.
;   Args:
;     R1:R2 = pointer
;   Returns:
;     R1:R2 = first non-space/tab character (or NUL)
;   Clobbers: R0, R6
; ---------------------------------------------------------------------------
SKIPSPACES:
SKIPSPACES_LOOP:
    LOADR R6, R1, R2
    JZ R6, SKIPSPACES_DONE

    ; if ' ' (0x20)
    SET #0x00, R0
    ADDR R6, R0
    CMP R0, #0x20
    JZ R0, SKIPSPACES_ADV

    ; if '\t' (0x09)
    SET #0x00, R0
    ADDR R6, R0
    CMP R0, #0x09
    JZ R0, SKIPSPACES_ADV

    RET

SKIPSPACES_ADV:
    INC R2
    JNZ R2, SKIPSPACES_LOOP
    INC R1
    JMP SKIPSPACES_LOOP

SKIPSPACES_DONE:
    RET


; ---------------------------------------------------------------------------
; READTOKEN
;   Read next token (space/tab delimited) from a string into a destination buffer.
;   Args:
;     R1:R2 = source pointer (NUL-terminated)
;     R3:R4 = destination buffer
;     R5    = max bytes in destination (including NUL)
;   Returns:
;     R0 = token length (0 if no token)
;     R1:R2 = updated source pointer (at delimiter or NUL)
;   Clobbers: R0, R5, R6, R7
;   Notes:
;     Always NUL-terminates dst if R5>0.
; ---------------------------------------------------------------------------
READTOKEN:
    SET #0x00, R0          ; len
    JZ R5, READTOKEN_DONE  ; cannot write anything

    ; Skip leading spaces/tabs
    CALL SKIPSPACES

    ; Reserve 1 byte for terminator in dst
    DEC R5
    JZ R5, READTOKEN_TERM

READTOKEN_LOOP:
    JZ R5, READTOKEN_TERM
    LOADR R6, R1, R2
    JZ R6, READTOKEN_TERM

    ; Stop on ' '
    SET #0x00, R7
    ADDR R6, R7
    CMP R7, #0x20
    JZ R7, READTOKEN_TERM

    ; Stop on '\t'
    SET #0x00, R7
    ADDR R6, R7
    CMP R7, #0x09
    JZ R7, READTOKEN_TERM

    ; Copy char
    STORER R6, R3, R4
    INC R0

    ; ++src
    INC R2
    JNZ R2, READTOKEN_SRC_OK
    INC R1
READTOKEN_SRC_OK:

    ; ++dst
    INC R4
    JNZ R4, READTOKEN_DST_OK
    INC R3
READTOKEN_DST_OK:

    DEC R5
    JMP READTOKEN_LOOP

READTOKEN_TERM:
    SET #0x00, R6
    STORER R6, R3, R4
READTOKEN_DONE:
    RET


; ---------------------------------------------------------------------------
; PARSE_U8_DEC
;   Parse an unsigned decimal integer (0..255) from a string.
;   Args:
;     R1:R2 = pointer to first character (digits expected)
;   Returns:
;     R0 = parsed value (0 if none)
;     R3 = status:
;            0 = no digits parsed
;            1 = success
;            2 = overflow (>255)
;     R1:R2 = updated pointer (first non-digit)
;   Clobbers: R4, R5, R6, R7
; ---------------------------------------------------------------------------
PARSE_U8_DEC:
    SET #0x00, R0
    SET #0x00, R3

PARSE_U8_LOOP:
    LOADR R4, R1, R2
    JZ R4, PARSE_U8_DONE

    ; if R4 < '0' => stop
    SET #0x00, R5
    ADDR R4, R5
    CMP R5, #0x30
    JC PARSE_U8_DONE

    ; if R4 >= ':' => stop  (':' is '9'+1)
    SET #0x00, R5
    ADDR R4, R5
    CMP R5, #0x3A
    JNC PARSE_U8_DONE

    ; digit = R4 - '0'
    SET #0x00, R5
    ADDR R4, R5
    SUB #0x30, R5

    ; mark that we parsed at least one digit
    SET #0x01, R3

    ; value = value*10 + digit, detect overflow
    SET #0x00, R6
    ADDR R0, R6
    ; NOTE: VM encoding uses (imm, dst_high, dst_low).
    ; We want low in R6 and high in R7.
    MUL #10, R7, R6        ; R6=low, R7=high
    JNZ R7, PARSE_U8_OVERFLOW
    SET #0x00, R0
    ADDR R6, R0

    ADDR R5, R0
    JC PARSE_U8_OVERFLOW

    ; ++ptr
    INC R2
    JNZ R2, PARSE_U8_LOOP
    INC R1
    JMP PARSE_U8_LOOP

PARSE_U8_OVERFLOW:
    SET #0x02, R3
    RET

PARSE_U8_DONE:
    RET
